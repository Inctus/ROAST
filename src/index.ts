import { DefaultMode, ReplicationMode } from "./lib/global/Enums";
import { StateTreeDefinition } from "./lib/global/Types";
import { StateNode } from "./lib/tree";
import { Definition, DefinitionBuilder } from "./lib/tree/definitions";

/**
 * ENUM Collection.
 */
export { DefaultMode, ReplicationMode };
export {};

export namespace ROAST {
	/** @hidden */
	export const ROAST_VERSION = "0.0.1";

	export enum ROAST_CONTEXT {
		ACTIVE,
	}

	// CONTEXTUALLY ACT

	/*
	IF ON SERVER
		USE SHARED TO DETECT IF I AM ALREADY RUNNING, IF I AM ERROR? WTF
		CREATE REMOTE EVENT

		WHEN CREATE DEFINITIONS IS CALLED, 
			SOMEHOW OBTAIN A LIST OF UUIDS FROM DEFINITIONBUILDER
			BIND LISTENER TO REMOTE EVENT TO PERFORM HANDSHAKE
		
		NOW WHEN YOU'VE RECEIVED HANDSHAKE,
			ASSERT NUMBER OF NODES IS CORRECT
			SEND BACK LIST OF UUIDS FROM DEFINITIONBUILDER

	*/

	/*
	IF ON CLIENT
		USE SHARED TO DETECT IF I AM ALREADY RUNNING, IF I AM ERROR? WTF
		LOOK FOR REMOTE EVENT WITH WAITFORCHILD

		WHEN CREATEDEFINITIONS IS CALLED,
			GET NUMBER OF NODES
			SEND HANDSHAKE PACKET WITH NUMBER OF NODES
			RECEIVE LIST,
				DFS DOWN TREES
				APPLY UUIDS
	*/

	/*
	REPLICATION WILL BE HANDLED ON A PER-NODE BASIS
	EACH NODE WILL NEED TO USE THE SAME REMOTE EVENTS, 
		SO POSSIBLY INJECT REMOTE EVENTS INTO NODES
		FROM DEFINITIONBUILDER.BUILD(GET, SET, SUBSCRIBE)
		THOSE PARAMETERS SHOULD BE WRAPPED REMOTE EVENTS

		THEY SHOULD EACH HAVE REPLICATIONQUEUES
		THEY SHOULD HAVE FUNCTIONS TO AUTOMATICALLY SWITCH
		BASED OFF OF A FIELD IN THE PACKETS
		WRAPPEDREMOTE.Bind(pattern, function)
		WHERE PATTERN IS A PATTERN TO BE FOLLOWED BY THE PACKET
		I.E. {type='update'}
		THEN THAT BIND WOULD BE CALLED WHEN THAT PATTERN IS MATCHED
			THIS WOULD ELIMINATE A LOT OF UNNECESSARY SWITCHING?
			CAN SCRAP IT IF IT'S A BAD IDEA IDK
	
	EACH NODE'S REPLICATOR SHOULD KNOW ABOUT IT'S UUID
	IT SHOULD ALSO CONTAIN A REPLICATIONQUEUE 
		OF REQUESTS WAITING TO BE SENT FOR THAT NODE
		THEY SHOULD NOT SEND ANYTHING TO THE WRAPPEDREMOTE
		UNTIL THEIR UUID HAS BEEN ASSIGNED
		THEY CANNOT BIND TO THE REMOTE UNTIL THEIR UUID HAS BEEN
		ASSIGNED EITHER, BECAUSE THEY NEED TO PATTERN MATCH
		FOR THEIR SPECIFIC UUID
	*/

	export function CreateDefinitions<T extends Record<string, StateNode>>(
		definitions: T,
		context: ROAST_CONTEXT = ROAST_CONTEXT.ACTIVE,
	): Definition<T> {
		return DefinitionBuilder.build(definitions);
	}
}
